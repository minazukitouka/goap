Part 1
------

# 什麼是 GOAP

Goal Oriented Action Planning
目標導向的行動規劃

給予一批的目標與行動, 根據狀態, 找出接下來要做的事情

步驟大致上如下:

1. 決定目標
2. 透過演算法找出所有可能的計劃
3. 採用成本最低的計劃
4. 當狀態發生改變, 或者計劃完成了, 回到第一點重新開始

## 優點

1. 低耦合的架構, 行動和目標之間幾乎沒有關聯, 也因為這樣所以有了以下的優點
2. 靈活, 隨時根據環境的改變, 重新生成新的目標, 實踐適合的計劃
3. 彈性, 可以很容易的隨時添加/移除新目標與新行動

## 缺點

1. 效能可能較差, 尤其是能做很多行動的單位, 尋找最佳計劃可能是很耗時的
2. 需要寫足行動, 才能完成一個目標, 而將來為了更細緻的控制, 可能需要拆成更細的行動
3. 不認真微調的話, AI 很可能會太聰明, 很可能因此破壞遊戲體驗
4. 不適合使用在玩家直接操控的角色

## 元件

### 狀態 (State)

狀態是一個集合, 但由於 Godot 沒有 Set 之類的類型, 因此使用 Dictionary
只要 key 存在之中, 就表示擁有這個狀態 (值是什麼不重要)
以下使用 (+state1 -state2) 表示有 state1 但沒有 state2

表達狀態的變化或有無, 也是使用 Dictionary, 此時使用 true 表示添加/擁有, 使用 false 表示移除/沒有
以下使用 (+state1 -state2) 表示增加 state1 移除 state2
稍後會提供更多的例子

### 目標 (Goal)

通常一個 AI 會有許多的目標, 目標的屬性有:

1. 是否可採用: 例如, 房子足夠的時候, 就可以不考慮蓋房子
2. 優先權多高: 當有多個目標可採用時, 選擇優先權最高的
   但如果優先權相等的情況下, 可以摻點隨機數增加不確定性
3. 目標狀態是什麼: 例如, 房子足夠

### 行動 (Action)

為了達到目標, 通常需要進行至少一個行動, 行動的屬性有:

1. 是否可採用
2. 花費: 可能是固定的, 也可能根據實際情況
   例如, 當附近沒有樹的時候, 尋找樹木的花費就會比平常高
3. 先決條件: 這和 "是否可採用" 不太一樣
   先決條件用於在規劃的時候, 用以判斷是否能夠成為一個計劃的起點, 表示目前的計劃已經足夠完整
4. 造成效果: 執行行動後, 預計會造成的效果

### 代理者 (Agent)

在這個系統中, 會有一個代理者, 通常會是場景的一個節點
代理者需要做事情有:

1. 儲存狀態
2. 知道所有的目標和行動
3. 決定目標, 安排計劃, 並且執行之

### 計劃 (Plan)

為了方便, 可以用特別的資料結構表示一個計劃, 或者簡單的用 Dictionary 也可以, 需要有這些屬性:

1. 總費用
2. 目前的目標狀態
3. 行動列表

## 範例

今天只會做比較簡單的幾個目標, 且不考慮費用:

伐木 GatherWood:
沒有庫存木頭時採用 (-has_stock_wood)
目標狀態是擁有庫存木頭 (+has_stock_wood)

蓋房子 BuildHouse:
人口上限不足, 且有庫存木頭時採用 (+need_house +has_stock_wood)
目標狀態是達到人口上限足夠 (-need_house)

閒置 Idle:
任何狀態都可以採用, 優先權最低
目標狀態是無 ()

一些行動的例子:

尋找木頭 FindWood:
先決條件: 無 ()
造成效果: 變成可伐木狀態 (+can_cut_wood)

伐木 CutWood:
先決條件: 必須為可伐木狀態 (+can_cut_wood)
造成效果: 獲得滿滿的木頭 (+has_gathering_wood)

送回木頭 ReturnWood
先決條件: 獲得滿滿的木頭 (+has_gathering_wood)
造成效果: 將木頭放到庫存中 (+has_stock_wood)

蓋房子 BuildHouse
先決條件: 庫存中有木頭且需要蓋房 (+has_stock_wood +need_house)
造成效果: 消耗庫存的木頭, 解決人口問題 ()

當村民的狀態是空 () 的時候, 他可以選擇伐木或者閒置作為目標, 伐木優先權會比閒置還高, 因此選擇伐木為目標
如何達到擁有庫存木頭 (+has_stock_wood) 的這個目標?

一個可能的計劃是:

1. 尋找木頭: 無需任何先決條件, 執行後狀態變為 (+can_cut_wood)
2. 伐木: 由於滿足了先決條件 (+can_cut_wood), 執行後狀態變為 (+has_gathering_wood)
3. 送回木頭: 由於滿足了先決條件 (+has_gathering_wood), 執行後狀態變為 (+has_stock_wood)

(+has_stock_wood) 滿足了 (+has_stock_wood) 的條件, 因此這會是個可行的計劃

當村民處於庫存有木頭, 又想蓋房子的時候 (+has_stock_wood +need_house), 就會選擇蓋房子為目標,
一個最簡短的計劃就出來了:

1. 蓋房子: 由於滿足了先決條件 (+has_stock_wood +need_house), 執行後狀態變為 ()

執行層面, 這次實況應該不會實作, 因為蠻花時間的...

To Be Continued...?

Part 2
------

今天目標:

1. 簡化方法並維持執行結果正確
2. 製作 Agent 讓它挑選目標
